"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.radixSort = exports.insertionSort = exports.binarySearchForInsertionIndex = exports.nativeSort = exports.isSorted = void 0;
const BEFORE = -1;
const EQUALS = 0;
const AFTER = 1;
function isSorted(networks) {
    if (networks.length > 1) {
        for (let i = 1; i < networks.length; i++) {
            let x = networks[i - 1].compare(networks[i]);
            if (x === AFTER || x === null)
                return false;
        }
    }
    return true;
}
exports.isSorted = isSorted;
function nativeSort(networks) {
    return networks.sort((a, b) => {
        let aBytes = a.addr.bytes();
        let bBytes = b.addr.bytes();
        if (aBytes.length !== bBytes.length)
            return aBytes.length - bBytes.length;
        for (let i = 0; i < aBytes.length; i++) {
            if (aBytes[i] !== bBytes[i])
                return aBytes[i] - bBytes[i];
        }
        if (a.cidr() !== b.cidr())
            return a.cidr() - b.cidr();
        return 0;
    });
}
exports.nativeSort = nativeSort;
function binarySearchForInsertionIndex(network, sortedNetworks) {
    if (!sortedNetworks || sortedNetworks.length === 0)
        return 0;
    let left = 0;
    let right = sortedNetworks.length - 1;
    while (left < right) {
        let middle = Math.floor(left + (right - left) / 2);
        switch (sortedNetworks[middle].compare(network)) {
            case EQUALS:
                return middle + 1;
            case BEFORE:
                left = middle + 1;
                break;
            case AFTER:
                right = middle - 1;
                break;
        }
    }
    if (sortedNetworks[left].compare(network) === BEFORE)
        return left + 1;
    return left;
}
exports.binarySearchForInsertionIndex = binarySearchForInsertionIndex;
function insertionSort(networks) {
    const sorted = [];
    networks.forEach((net) => {
        let idx = binarySearchForInsertionIndex(net, sorted);
        sorted.splice(idx, 0, net);
    });
    return sorted;
}
exports.insertionSort = insertionSort;
function msdRadixSort(networks, start, stop, byteIndex) {
    if (start >= stop - 1)
        return;
    const runningPrefixSum = new Array(256);
    const offsetPrefixSum = new Array(256);
    const counts = runningPrefixSum;
    for (let i = 0; i < counts.length; i++) {
        counts[i] = 0;
    }
    for (let i = start; i < stop; i++) {
        let byteValue;
        switch (byteIndex) {
            case -1:
                byteValue = networks[i].addr.bytes().length;
                break;
            case 16:
                byteValue = networks[i].cidr();
                break;
            default:
                if (byteIndex < networks[i].addr.bytes().length) {
                    byteValue = networks[i].addr.bytes()[byteIndex];
                }
                else {
                    byteValue = 0;
                }
        }
        counts[byteValue]++;
    }
    let lastCount = counts[counts.length - 1];
    let total = 0;
    let oldCount = 0;
    for (let i = 0; i < 256; i++) {
        oldCount = counts[i];
        runningPrefixSum[i] = total;
        total += oldCount;
    }
    for (let i = 0; i < 256; i++) {
        if (i < 255) {
            offsetPrefixSum[i] = runningPrefixSum[i + 1];
        }
        else {
            offsetPrefixSum[i] = runningPrefixSum[i] + lastCount;
        }
    }
    let redIndex = start;
    let redValue = 0;
    while (redIndex < stop) {
        switch (byteIndex) {
            case -1:
                redValue = networks[redIndex].addr.bytes().length;
                break;
            case 16:
                redValue = networks[redIndex].cidr();
                break;
            default:
                if (byteIndex < networks[redIndex].addr.bytes().length) {
                    redValue = networks[redIndex].addr.bytes()[byteIndex];
                }
                else {
                    redValue = 0;
                }
        }
        let blueIndex = start + runningPrefixSum[redValue];
        if (runningPrefixSum[redValue] < offsetPrefixSum[redValue]) {
            runningPrefixSum[redValue]++;
            if (redIndex === blueIndex) {
                redIndex++;
            }
            else {
                let oldRedNetwork = networks[redIndex];
                networks[redIndex] = networks[blueIndex];
                networks[blueIndex] = oldRedNetwork;
            }
        }
        else {
            redIndex++;
        }
    }
    if (byteIndex < 16) {
        let lastPrefixSum = 0;
        for (let i = 0; i < runningPrefixSum.length; i++) {
            if (runningPrefixSum[i] !== lastPrefixSum) {
                msdRadixSort(networks, start + lastPrefixSum, start + runningPrefixSum[i], byteIndex + 1);
            }
            lastPrefixSum = runningPrefixSum[i];
        }
    }
}
function radixSort(networks) {
    msdRadixSort(networks, 0, networks.length, -1);
}
exports.radixSort = radixSort;
//# sourceMappingURL=sort.js.map