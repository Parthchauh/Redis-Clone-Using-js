"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summarize = exports.sort = exports.rangeOfNetworks = exports.nextNetwork = exports.nextAddress = exports.networksIntersect = exports.networkContainsSubnet = exports.networkContainsAddress = exports.networkComesBefore = exports.network = exports.ip = exports.findUnusedSubnets = exports.broadcastAddress = exports.baseAddress = void 0;
const shared = __importStar(require("./shared"));
const errors = __importStar(require("./errors"));
const network_1 = require("./network");
const address_1 = require("./address");
const match_1 = require("./match");
const BEFORE = -1;
const EQUALS = 0;
const AFTER = 1;
function baseAddress(networkAddress, throwErrors) {
    const net = new network_1.Network(networkAddress, throwErrors);
    if (!net.isValid())
        return null;
    net.addr.applySubnetMask(net.cidr());
    return net.addr.toString();
}
exports.baseAddress = baseAddress;
function broadcastAddress(network, throwErrors) {
    const net = new network_1.Network(network, throwErrors);
    if (!net.isValid() || net.addr.bytes().length === 16)
        return null;
    net.addr.applySubnetMask(net.cidr());
    return net.lastAddr().toString();
}
exports.broadcastAddress = broadcastAddress;
function findUnusedSubnets(aggregate, subnets, strict, throwErrors) {
    const agg = shared.parseBaseNetwork(aggregate, strict, throwErrors);
    if (!agg || !agg.isValid())
        return null;
    let subnetworks = [];
    for (let s of subnets) {
        const net = shared.parseBaseNetwork(s, strict, throwErrors);
        if (!net || !net.isValid()) {
            if (strict)
                return null;
            continue;
        }
        if (agg.addr.bytes().length === net.addr.bytes().length) {
            subnetworks.push(net);
        }
    }
    shared.sortNetworks(subnetworks);
    const unused = shared.findNetworkGaps(agg, subnetworks);
    return Array.from(unused, (net) => net.toString());
}
exports.findUnusedSubnets = findUnusedSubnets;
function ip(address, throwErrors) {
    const addr = new address_1.Address(address, throwErrors).toString();
    return addr.length > 0 ? addr : null;
}
exports.ip = ip;
function network(networkAddress, throwErrors) {
    const net = new network_1.Network(networkAddress, throwErrors).toString();
    return net.length > 0 ? net : null;
}
exports.network = network;
function networkComesBefore(network, otherNetwork, strict, throwErrors) {
    const alphaNet = shared.parseBaseNetwork(network, strict, throwErrors);
    if (!alphaNet || !alphaNet.isValid())
        return null;
    const bravoNet = shared.parseBaseNetwork(otherNetwork, strict, throwErrors);
    if (!bravoNet || !bravoNet.isValid())
        return null;
    switch (alphaNet.compare(bravoNet)) {
        case BEFORE:
            return true;
        case AFTER:
            return false;
    }
    if (alphaNet.cidr() < bravoNet.cidr())
        return true;
    return false;
}
exports.networkComesBefore = networkComesBefore;
function networkContainsAddress(network, address, strict, throwErrors) {
    const net = shared.parseBaseNetwork(network, strict, throwErrors);
    if (!net || !net.isValid())
        return null;
    const addrNet = new network_1.Network(address, throwErrors);
    if (!addrNet.isValid())
        return null;
    if (addrNet.cidr() !== addrNet.addr.bytes().length * 8) {
        if (throwErrors)
            throw errors.InvalidAddress;
        return null;
    }
    return net.contains(addrNet);
}
exports.networkContainsAddress = networkContainsAddress;
function networkContainsSubnet(network, subnet, strict, throwErrors) {
    const alphaNet = shared.parseBaseNetwork(network, strict, throwErrors);
    if (!alphaNet)
        return null;
    const bravoNet = shared.parseBaseNetwork(subnet, strict, throwErrors);
    if (!bravoNet)
        return null;
    return alphaNet.contains(bravoNet);
}
exports.networkContainsSubnet = networkContainsSubnet;
function networksIntersect(network, otherNetwork, strict, throwErrors) {
    const alphaNet = shared.parseBaseNetwork(network, strict, throwErrors);
    if (!alphaNet)
        return null;
    const bravoNet = shared.parseBaseNetwork(otherNetwork, strict, throwErrors);
    if (!bravoNet)
        return null;
    return alphaNet.intersects(bravoNet);
}
exports.networksIntersect = networksIntersect;
function nextAddress(address, throwErrors) {
    const addr = new address_1.Address(address, throwErrors);
    if (!addr.isValid())
        return null;
    if (!addr.next().isValid()) {
        if (throwErrors)
            throw errors.OverflowedAddressSpace;
        return null;
    }
    return addr.toString();
}
exports.nextAddress = nextAddress;
function nextNetwork(network, strict, throwErrors) {
    const net = shared.parseBaseNetwork(network, strict, throwErrors);
    if (!net || !net.isValid())
        return null;
    if (!net.next().isValid()) {
        if (throwErrors)
            throw errors.OverflowedAddressSpace;
        return null;
    }
    return net.toString();
}
exports.nextNetwork = nextNetwork;
function rangeOfNetworks(startAddress, stopAddress, throwErrors) {
    let startAddr = new address_1.Address(startAddress, throwErrors);
    if (!startAddr)
        return null;
    let stopAddr = new address_1.Address(stopAddress, throwErrors);
    if (!stopAddr)
        return null;
    if (startAddr.bytes().length !== stopAddr.bytes().length) {
        if (throwErrors)
            throw errors.MixingIPv4AndIPv6;
        return null;
    }
    switch (startAddr.compare(stopAddr)) {
        case EQUALS:
            return [`${startAddress}/${startAddr.bytes().length * 8}`];
        case AFTER:
            [startAddr, stopAddr] = [stopAddr, startAddr];
    }
    let results = [];
    const net = new network_1.Network().from(startAddr, 0);
    while (net.addr.lessThanOrEqual(stopAddr)) {
        while (!net.addr.isBaseAddress(net.cidr()) || net.lastAddr().greaterThan(stopAddr)) {
            net.setCIDR(net.cidr() + 1);
        }
        results.push(net.toString());
        net.next().setCIDR(0);
    }
    return results;
}
exports.rangeOfNetworks = rangeOfNetworks;
function sort(networkAddresses, throwErrors) {
    let subnets = new Array(networkAddresses.length);
    let foundCIDR = false;
    for (let i = 0; i < networkAddresses.length; i++) {
        const addr = new address_1.Address(networkAddresses[i], throwErrors);
        if (!addr)
            return null;
        let cidr = shared.getCIDR(networkAddresses[i]);
        if (!cidr) {
            if (addr.bytes().length == 4) {
                cidr = 32;
            }
            else {
                cidr = 128;
            }
        }
        else {
            foundCIDR = true;
        }
        subnets[i] = new network_1.Network().from(addr, cidr);
    }
    shared.sortNetworks(subnets);
    const results = new Array(subnets.length);
    for (let i = 0; i < subnets.length; i++) {
        if (foundCIDR) {
            results[i] = subnets[i].toString();
        }
        else {
            results[i] = subnets[i].addr.toString();
        }
    }
    return results;
}
exports.sort = sort;
function summarize(networks, strict, throwErrors) {
    let subnets = [];
    for (let i = 0; i < networks.length; i++) {
        const net = shared.parseBaseNetwork(networks[i], strict, false);
        if (net) {
            if (net.isValid()) {
                subnets.push(net);
            }
        }
        else if (strict) {
            if (throwErrors)
                throw errors.NotValidBaseNetworkAddress;
            return null;
        }
    }
    shared.sortNetworks(subnets);
    subnets = shared.summarizeSortedNetworks(subnets);
    const results = new Array(subnets.length);
    for (let i = 0; i < subnets.length; i++) {
        results[i] = subnets[i].toString();
    }
    return results;
}
exports.summarize = summarize;
var match_2 = require("./match");
Object.defineProperty(exports, "Matcher", { enumerable: true, get: function () { return match_2.Matcher; } });
module.exports = {
    Matcher: match_1.Matcher,
    baseAddress,
    broadcastAddress,
    findUnusedSubnets,
    ip,
    network,
    networkComesBefore,
    networkContainsAddress,
    networkContainsSubnet,
    networksIntersect,
    nextAddress,
    nextNetwork,
    rangeOfNetworks,
    sort,
    summarize
};
//# sourceMappingURL=index.js.map