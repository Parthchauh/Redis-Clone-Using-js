"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseBaseNetwork = exports.findNetworkGaps = exports.summarizeSortedNetworks = exports.sortNetworks = exports.getCIDR = void 0;
const sort = __importStar(require("./sort"));
const errors = __importStar(require("./errors"));
const network_1 = require("./network");
function getCIDR(s, throwErrors) {
    const splitAddr = s.split("/");
    if (splitAddr.length === 2) {
        const val = Number(splitAddr[1]);
        if (Number.isInteger(val)) {
            const maxCIDR = splitAddr[0].search(":") >= 0 ? 128 : 32;
            if (0 < val && val <= maxCIDR)
                return val;
        }
    }
    if (throwErrors)
        throw errors.GenericGetCIDR;
    return null;
}
exports.getCIDR = getCIDR;
function sortNetworks(networks) {
    sort.nativeSort(networks);
}
exports.sortNetworks = sortNetworks;
function increaseSizeByOneBit(network) {
    const wider = network.setCIDR(network.cidr() - 1);
    wider.addr.applySubnetMask(wider.cidr());
    return wider;
}
function summarizeSortedNetworks(sorted) {
    const summarized = sorted.slice(0, 1);
    for (let idx = 1; idx < sorted.length; idx++) {
        if (summarized[summarized.length - 1].contains(sorted[idx])) {
            continue;
        }
        summarized.push(sorted[idx]);
        while (summarized.length >= 2) {
            const a = summarized[summarized.length - 2];
            const b = summarized[summarized.length - 1];
            if (a.cidr() != b.cidr() || !a.addr.isBaseAddress(a.cidr() - 1) || !a.adjacent(b)) {
                break;
            }
            increaseSizeByOneBit(a);
            summarized.pop();
        }
    }
    return summarized;
}
exports.summarizeSortedNetworks = summarizeSortedNetworks;
function findNetworkGaps(aggregate, sortedSubnets) {
    let idx = 0;
    const results = [];
    const canidate = aggregate.duplicate();
    const lastAddr = aggregate.lastAddr();
    while (canidate.addr.lessThanOrEqual(lastAddr)) {
        while (!canidate.addr.isBaseAddress(canidate.cidr()) || !aggregate.contains(canidate)) {
            canidate.setCIDR(canidate.cidr() + 1);
        }
        if (idx < sortedSubnets.length && canidate.intersects(sortedSubnets[idx])) {
            if (canidate.cidr() < 8 * aggregate.addr.bytes().length) {
                canidate.setCIDR(canidate.cidr() + 1);
            }
            else {
                let sn = sortedSubnets[idx].duplicate();
                canidate.addr.setBytes(sn.next().addr.bytes());
                canidate.setCIDR(aggregate.cidr());
                idx++;
            }
        }
        else {
            let net = canidate.duplicate();
            results.push(net);
            canidate.next().setCIDR(aggregate.cidr());
        }
    }
    return results;
}
exports.findNetworkGaps = findNetworkGaps;
function parseBaseNetwork(s, strict, throwErrors) {
    const net = new network_1.Network(s, throwErrors);
    if (!net.isValid())
        return null;
    if (!strict) {
        net.addr.applySubnetMask(net.cidr());
    }
    else {
        const original = net.addr.duplicate();
        net.addr.applySubnetMask(net.cidr());
        if (!net.addr.equals(original)) {
            if (throwErrors)
                throw errors.NotValidBaseNetworkAddress;
            return null;
        }
    }
    return net;
}
exports.parseBaseNetwork = parseBaseNetwork;
//# sourceMappingURL=shared.js.map